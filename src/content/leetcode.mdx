import { CodeSandbox } from '@/components/CodeSandbox'

[LeetCode 热题 100](https://leetcode.cn/studyplan/top-100-liked/)

## 数组相关

### 1 两数之和

<Sandpack>

```js
import { useState } from 'react'

export default function TwoSumDemo() {
  const [result, setResult] = useState('')

  function twoSum(nums, target) {
    const diffs = {}
    const len = nums.length
    for (let i = 0; i < len; i++) {
      if (diffs[target - nums[i]] !== undefined) {
        return [diffs[target - nums[i]], i]
      }
      diffs[nums[i]] = i
    }
  }

  function handleClick() {
    setResult(JSON.stringify(twoSum([2, 7, 11, 15], 9)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试两数之和</button>
      <div>结果：{result}</div>
      88{' '}
    </div>
  )
}
```

</Sandpack>

### 88 合并两个有序数组

<Sandpack>

```js
import { useState } from 'react'

export default function MergeArrayDemo() {
  const [result, setResult] = useState('')

  function merge(nums1, m, nums2, n) {
    let i = m - 1,
      j = n - 1,
      k = m + n - 1
    while (i >= 0 && j >= 0) {
      if (nums1[i] >= nums2[j]) {
        nums1[k] = nums1[i]
        i--
        k--
      } else {
        nums1[k] = nums2[j]
        j--
        k--
      }
    }
    while (j >= 0) {
      nums1[k] = nums2[j]
      k--
      j--
    }
    return nums1
  }

  function handleClick() {
    setResult(JSON.stringify(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试合并有序数组</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

### 三数之和

<Sandpack>

```js
import { useState } from 'react'

export default function ThreeSumDemo() {
  const [result, setResult] = useState('')

  function threeSum(nums) {
    let res = []
    nums = nums.sort((a, b) => a - b)
    const len = nums.length
    for (let i = 0; i < len - 2; i++) {
      let j = i + 1
      let k = len - 1
      if (i > 0 && nums[i] === nums[i - 1]) continue
      while (j < k) {
        if (nums[i] + nums[j] + nums[k] < 0) {
          j++
          while (j < k && nums[j] === nums[j - 1]) j++
        } else if (nums[i] + nums[j] + nums[k] > 0) {
          k--
          while (j < k && nums[k] === nums[k + 1]) k--
        } else {
          res.push([nums[i], nums[j], nums[k]])
          j++
          k--
          while (j < k && nums[j] === nums[j - 1]) j++
          while (j < k && nums[k] === nums[k + 1]) k--
        }
      }
    }
    return res
  }

  function handleClick() {
    setResult(JSON.stringify(threeSum([-1, 0, 1, 2, -1, -4])))
  }

  return (
    <div>
      <button onClick={handleClick}>测试三数之和</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

### 长度最小的子数组

```js

```

## 字符串操作

### 验证回文字符串 {/* validate-palindrome */}

<Sandpack>

```js
import { useState } from 'react'

export default function PalindromeDemo() {
  const [result, setResult] = useState('')

  function isPalindrome(str) {
    const len = str.length
    for (let i = 0; i < len / 2; i++) {
      if (str[i] !== str[len - i - 1]) {
        return false
      }
    }
    return true
  }

  function handleClick() {
    setResult(isPalindrome('abccba') ? '是回文' : '不是回文')
  }

  return (
    <div>
      <button onClick={handleClick}>测试回文字符串</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

### 最多删除一个字符。判断是否能成为回文字符串 {/* valid-palindrome-ii */}

<Sandpack>

```js
import { useState } from 'react'

export default function ValidPalindromeDemo() {
  const [result, setResult] = useState('')

  function validPalindrome(s) {
    const len = s.length
    let i = 0,
      j = len - 1
    while (i < j && s[i] === s[j]) {
      i++
      j--
    }
    if (isPalindrome(i + 1, j)) return true
    if (isPalindrome(i, j - 1)) return true
    function isPalindrome(st, ed) {
      while (st < ed) {
        if (s[st] !== s[ed]) return false
        st++
        ed--
      }
      return true
    }
    return false
  }

  function handleClick() {
    setResult(validPalindrome('abca') ? '可以' : '不可以')
  }

  return (
    <div>
      <button onClick={handleClick}>测试最多删除一个字符回文</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

## 链表问题

### 合并两个有序链表

<Sandpack>

```js
import { useState } from 'react'

class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

export default function MergeTwoListsDemo() {
  const [result, setResult] = useState('')

  function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0)
    // 穿针引线，也有点像双指针
    let curr = dummy
    while (l1 && l2) {
      if (l1.val < l2.val) {
        curr.next = l1
        l1 = l1.next
      } else {
        curr.next = l2
        l2 = l2.next
      }
      curr = curr.next
    }
    curr.next = l1 || l2
    return dummy.next
  }

  function arrayToList(arr) {
    if (!arr.length) return null
    const head = new ListNode(arr[0])
    let curr = head
    for (let i = 1; i < arr.length; i++) {
      curr.next = new ListNode(arr[i])
      curr = curr.next
    }
    return head
  }

  function listToArray(head) {
    const result = []
    while (head) {
      result.push(head.val)
      head = head.next
    }
    return result
  }

  function handleClick() {
    const l1 = arrayToList([1, 2, 4])
    const l2 = arrayToList([1, 3, 4])
    const merged = mergeTwoLists(l1, l2)
    setResult(JSON.stringify(listToArray(merged)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试合并两个有序链表</button>
      <div>结果：{result}</div>
      <div>测试用例：[1,2,4] 和 [1,3,4]</div>
    </div>
  )
}
```

</Sandpack>

### 删除链表倒数第 N 个节点

<Sandpack>

```js
import { useState } from 'react'

class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

export default function RemoveNthFromEndDemo() {
  const [result, setResult] = useState('')

  function removeNthFromEnd(head, n) {
    const dummy = new ListNode(0)
    dummy.next = head
    let fast = dummy
    let slow = dummy

    // 快指针先走n+1步
    for (let i = 0; i <= n; i++) {
      fast = fast.next
    }

    // 快慢指针一起走
    while (fast) {
      fast = fast.next
      slow = slow.next
    }
    slow.next = slow.next.next
    return dummy.next
  }

  function arrayToList(arr) {
    if (!arr.length) return null
    const head = new ListNode(arr[0])
    let curr = head
    for (let i = 1; i < arr.length; i++) {
      curr.next = new ListNode(arr[i])
      curr = curr.next
    }
    return head
  }

  function listToArray(head) {
    const result = []
    while (head) {
      result.push(head.val)
      head = head.next
    }
    return result
  }

  function handleClick() {
    const head = arrayToList([1, 2, 3, 4, 5])
    const newHead = removeNthFromEnd(head, 2)
    setResult(JSON.stringify(listToArray(newHead)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试删除链表倒数第N个节点</button>
      <div>结果：{result}</div>
      <div>测试用例：[1,2,3,4,5] 删除倒数第2个节点</div>
      <div>解释：使用快慢指针，快指针先走n+1步</div>
    </div>
  )
}
```

</Sandpack>

### 反转链表

<Sandpack>

```js
import { useState } from 'react'

class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

export default function ReverseListDemo() {
  const [result, setResult] = useState('')

  function reverseList(head) {
    let prev = null
    let curr = head
    while (curr) {
      const next = curr.next // 记录下一个节点
      curr.next = prev
      prev = curr
      curr = next
    }
    return prev
  }

  function arrayToList(arr) {
    if (!arr.length) return null
    const head = new ListNode(arr[0])
    let curr = head
    for (let i = 1; i < arr.length; i++) {
      curr.next = new ListNode(arr[i])
      curr = curr.next
    }
    return head
  }

  function listToArray(head) {
    const result = []
    while (head) {
      result.push(head.val)
      head = head.next
    }
    return result
  }

  function handleClick() {
    const head = arrayToList([1, 2, 3, 4, 5])
    const reversed = reverseList(head)
    setResult(JSON.stringify(listToArray(reversed)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试反转链表</button>
      <div>结果：{result}</div>
      <div>测试用例：[1,2,3,4,5]</div>
      <div>解释：使用三个指针（prev, curr, next）记录状态</div>
    </div>
  )
}
```

</Sandpack>

### 环形链表检测

<Sandpack>

```js
import { useState } from 'react'

class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val
    this.next = next === undefined ? null : next
  }
}

export default function HasCycleDemo() {
  const [result, setResult] = useState('')

  function hasCycle(head) {
    let slow = head
    let fast = head
    while (fast && fast.next) {
      slow = slow.next
      fast = fast.next.next
      if (slow === fast) return true
    }
    return false
  }

  function createCycleList() {
    const node1 = new ListNode(3)
    const node2 = new ListNode(2)
    const node3 = new ListNode(0)
    const node4 = new ListNode(-4)

    node1.next = node2
    node2.next = node3
    node3.next = node4
    node4.next = node2 // 形成环

    return node1
  }

  function createNormalList() {
    const node1 = new ListNode(1)
    const node2 = new ListNode(2)
    const node3 = new ListNode(3)

    node1.next = node2
    node2.next = node3

    return node1
  }

  function handleCycleTest() {
    const cycleList = createCycleList()
    setResult(`有环链表：${hasCycle(cycleList)}`)
  }

  function handleNormalTest() {
    const normalList = createNormalList()
    setResult(`无环链表：${hasCycle(normalList)}`)
  }

  return (
    <div>
      <button onClick={handleCycleTest}>测试有环链表</button>
      <button onClick={handleNormalTest}>测试无环链表</button>
      <div>结果：{result}</div>
      <div>解释：使用快慢指针，如果有环快指针会追上慢指针</div>
    </div>
  )
}
```

</Sandpack>

## 栈

### 有效的括号

<Sandpack>

```js
import { useState } from 'react'

export default function ValidParenthesesDemo() {
  const [result, setResult] = useState('')
  const [input, setInput] = useState('()[]{}')

  function isValid(s) {
    const stack = []
    const map = {
      '(': ')',
      '[': ']',
      '{': '}'
    }

    for (let char of s) {
      if (map[char]) {
        // 左括号入栈
        stack.push(char)
      } else {
        // 右括号时检查匹配
        if (stack.length === 0 || map[stack.pop()] !== char) {
          return false
        }
      }
    }
    return stack.length === 0
  }

  function handleTest() {
    setResult(`"${input}" 是${isValid(input) ? '有效' : '无效'}的括号`)
  }

  function testCase(testStr) {
    setInput(testStr)
    setResult(`"${testStr}" 是${isValid(testStr) ? '有效' : '无效'}的括号`)
  }

  return (
    <div>
      <div>
        <input value={input} onChange={(e) => setInput(e.target.value)} placeholder="输入括号字符串" />
        <button onClick={handleTest}>测试</button>
      </div>
      <div>
        <button onClick={() => testCase('()')}>测试: ()</button>
        <button onClick={() => testCase('()[]{}')}>测试: ()[]&#123;&#125;</button>
        <button onClick={() => testCase('(]')}>测试: (]</button>
        <button onClick={() => testCase('([)]')}>测试: ([)]</button>
      </div>
      <div>结果：{result}</div>
      <div>解释：使用栈，左括号入栈，右括号时检查是否匹配</div>
    </div>
  )
}
```

</Sandpack>

## 队列

### 滑动窗口

```js

```

## 树相关

### 二叉树的前序遍历

<Sandpack>

```js
import { useState } from 'react'

class TreeNode {
  constructor(val, left, right) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

export default function PreorderTraversalDemo() {
  const [result, setResult] = useState('')

  function preorderTraversal(root) {
    const result = []
    function traverse(node) {
      if (!node) return
      result.push(node.val) // 访问根节点
      traverse(node.left) // 遍历左子树
      traverse(node.right) // 遍历右子树
    }
    traverse(root)
    return result
  }

  function createBinaryTree() {
    // 构建测试树：     1
    //               /   \
    //             null   2
    //                   /
    //                  3
    const root = new TreeNode(1)
    root.right = new TreeNode(2)
    root.right.left = new TreeNode(3)
    return root
  }

  function handleClick() {
    const root = createBinaryTree()
    const traversalResult = preorderTraversal(root)
    setResult(JSON.stringify(traversalResult))
  }

  return (
    <div>
      <button onClick={handleClick}>测试前序遍历</button>
      <div>结果：{result}</div>
      <div>测试树结构： 1 -> null, 2 -> 3, null</div>
      <div>前序遍历顺序：根 -> 左 -> 右</div>
    </div>
  )
}
```

</Sandpack>

### 二叉树的层序遍历

<Sandpack>

```js
import { useState } from 'react'

class TreeNode {
  constructor(val, left, right) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}

export default function LevelOrderDemo() {
  const [result, setResult] = useState('')

  function levelOrder(root) {
    if (!root) return []
    const result = []
    const queue = [root]

    while (queue.length) {
      const level = []
      const size = queue.length

      // 处理当前层的所有节点
      for (let i = 0; i < size; i++) {
        const node = queue.shift()
        level.push(node.val)

        // 将下一层的节点加入队列
        if (node.left) queue.push(node.left)
        if (node.right) queue.push(node.right)
      }
      result.push(level)
    }
    return result
  }

  function createBinaryTree() {
    //       3
    //      / \
    //     9   20
    //        /  \
    //       15   7
    const root = new TreeNode(3)
    root.left = new TreeNode(9)
    root.right = new TreeNode(20)
    root.right.left = new TreeNode(15)
    root.right.right = new TreeNode(7)
    return root
  }

  function handleClick() {
    const root = createBinaryTree()
    const traversalResult = levelOrder(root)
    setResult(JSON.stringify(traversalResult))
  }

  return (
    <div>
      <button onClick={handleClick}>测试层序遍历</button>
      <div>结果：{result}</div>
      <div>测试树结构：</div>
      <pre>
        {`      3
     / \\
    9   20
       /  \\
      15   7`}
      </pre>
      <div>层序遍历：逐层从左到右访问节点</div>
    </div>
  )
}
```

</Sandpack>

## 排序和搜索

### 快速排序

<Sandpack>

```js
import { useState } from 'react'

export default function QuickSortDemo() {
  const [result, setResult] = useState('')
  const [input, setInput] = useState('64,34,25,12,22,11,90')

  function quickSort(arr) {
    if (arr.length <= 1) return arr

    const pivot = arr[0] // 选择第一个元素作为基准
    const left = []
    const right = []

    // 分区：小于基准的放左边，大于等于的放右边
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] < pivot) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }

    // 递归排序左右两部分，然后合并
    return [...quickSort(left), pivot, ...quickSort(right)]
  }

  function handleSort() {
    try {
      const arr = input
        .split(',')
        .map((num) => parseInt(num.trim()))
        .filter((num) => !isNaN(num))
      const sorted = quickSort([...arr])
      setResult(`原数组: [${arr.join(', ')}]\n排序后: [${sorted.join(', ')}]`)
    } catch (error) {
      setResult('请输入有效的数字，用逗号分隔')
    }
  }

  function testCase(testArr) {
    const arrStr = testArr.join(',')
    setInput(arrStr)
    const sorted = quickSort([...testArr])
    setResult(`原数组: [${testArr.join(', ')}]\n排序后: [${sorted.join(', ')}]`)
  }

  return (
    <div>
      <div>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="输入数字，用逗号分隔"
          style={{ width: '200px' }}
        />
        <button onClick={handleSort}>快速排序</button>
      </div>
      <div>
        <button onClick={() => testCase([64, 34, 25, 12, 22, 11, 90])}>测试用例1</button>
        <button onClick={() => testCase([3, 1, 4, 1, 5, 9, 2, 6])}>测试用例2</button>
        <button onClick={() => testCase([5, 4, 3, 2, 1])}>测试用例3</button>
      </div>
      <pre>结果：{result}</pre>
      <div>算法思想：分治法，选择基准元素，分区，递归排序</div>
    </div>
  )
}
```

</Sandpack>

### 二分查找

<Sandpack>

```js
import { useState } from 'react'

export default function BinarySearchDemo() {
  const [result, setResult] = useState('')
  const [target, setTarget] = useState('9')

  function binarySearch(nums, target) {
    let left = 0
    let right = nums.length - 1

    while (left <= right) {
      const mid = Math.floor((left + right) / 2)

      if (nums[mid] === target) {
        return mid // 找到目标，返回索引
      }

      if (nums[mid] < target) {
        left = mid + 1 // 目标在右半部分
      } else {
        right = mid - 1 // 目标在左半部分
      }
    }

    return -1 // 未找到
  }

  function handleSearch() {
    const nums = [-1, 0, 3, 5, 9, 12]
    const targetNum = parseInt(target)
    const index = binarySearch(nums, targetNum)

    if (index !== -1) {
      setResult(`在数组 [${nums.join(', ')}] 中找到 ${targetNum}，索引为: ${index}`)
    } else {
      setResult(`在数组 [${nums.join(', ')}] 中未找到 ${targetNum}`)
    }
  }

  function testCase(arr, targetNum) {
    const index = binarySearch(arr, targetNum)
    if (index !== -1) {
      setResult(`在数组 [${arr.join(', ')}] 中找到 ${targetNum}，索引为: ${index}`)
    } else {
      setResult(`在数组 [${arr.join(', ')}] 中未找到 ${targetNum}`)
    }
  }

  return (
    <div>
      <div>
        <input
          value={target}
          onChange={(e) => setTarget(e.target.value)}
          placeholder="输入要查找的数字"
          style={{ width: '150px' }}
        />
        <button onClick={handleSearch}>在 [-1,0,3,5,9,12] 中查找</button>
      </div>
      <div>
        <button onClick={() => testCase([-1, 0, 3, 5, 9, 12], 9)}>查找 9</button>
        <button onClick={() => testCase([-1, 0, 3, 5, 9, 12], 2)}>查找 2</button>
        <button onClick={() => testCase([1, 3, 5, 7, 9, 11], 7)}>查找 7</button>
      </div>
      <div>结果：{result}</div>
      <div>算法思想：在有序数组中，每次排除一半元素，时间复杂度 O(log n)</div>
    </div>
  )
}
```

</Sandpack>

## 动态规划

### 爬楼梯问题

<Sandpack>

```js
import { useState } from 'react'

export default function ClimbStairsDemo() {
  const [result, setResult] = useState('')
  const [stairs, setStairs] = useState('5')

  function climbStairs(n) {
    if (n <= 2) return n

    let dp = [1, 2] // dp[0] = 1, dp[1] = 2

    // 从第3级台阶开始计算
    for (let i = 2; i < n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2] // 状态转移方程
    }

    return dp[n - 1]
  }

  function handleCalculate() {
    const n = parseInt(stairs)
    if (isNaN(n) || n <= 0) {
      setResult('请输入有效的正整数')
      return
    }

    const ways = climbStairs(n)
    setResult(`爬 ${n} 级台阶共有 ${ways} 种方法`)
  }

  function testCase(n) {
    setStairs(n.toString())
    const ways = climbStairs(n)
    setResult(`爬 ${n} 级台阶共有 ${ways} 种方法`)
  }

  function showSteps(n) {
    if (n <= 0) return '无效输入'
    if (n === 1) return '1种方法: [1]'
    if (n === 2) return '2种方法: [1,1] 或 [2]'

    const ways = climbStairs(n)
    return `${ways} 种方法（每次可以爬1或2级台阶）`
  }

  return (
    <div>
      <div>
        <input
          value={stairs}
          onChange={(e) => setStairs(e.target.value)}
          placeholder="输入台阶数"
          style={{ width: '100px' }}
        />
        <button onClick={handleCalculate}>计算方法数</button>
      </div>
      <div>
        <button onClick={() => testCase(1)}>1级台阶</button>
        <button onClick={() => testCase(2)}>2级台阶</button>
        <button onClick={() => testCase(3)}>3级台阶</button>
        <button onClick={() => testCase(5)}>5级台阶</button>
        <button onClick={() => testCase(10)}>10级台阶</button>
      </div>
      <div>结果：{result}</div>
      <div>规律：{stairs && !isNaN(parseInt(stairs)) ? showSteps(parseInt(stairs)) : ''}</div>
      <div>状态转移：到达第n级台阶 = 到达第(n-1)级台阶的方法数 + 到达第(n-2)级台阶的方法数</div>
    </div>
  )
}
```

</Sandpack>

### LRU 缓存

<Sandpack>

```js
import { useState } from 'react'

export default function LRUCacheDemo() {
  const [result, setResult] = useState('')

  class LRUCache {
    constructor(capacity) {
      this.capacity = capacity // 缓存容量
      this.cache = new Map() // 缓存
    }
    get(key) {
      // 如果缓存中没有该key，返回-1
      if (!this.cache.has(key)) return -1
      const value = this.cache.get(key)
      // 删除该key
      this.cache.delete(key)
      // 将该key重新插入到缓存中
      this.cache.set(key, value)
      // 返回该key的值
      return value
    }
    put(key, value) {
      // 如果缓存中已经存在该key，删除该key
      if (this.cache.has(key)) {
        this.cache.delete(key)
      } else if (this.cache.size >= this.capacity) {
        // 如果缓存容量已满，删除最久未使用的key
        this.cache.delete(this.cache.keys().next().value)
      }
      // 将该key插入到缓存中
      this.cache.set(key, value)
    }
  }

  function handleClick() {
    const lru = new LRUCache(2)
    lru.put(1, 1)
    lru.put(2, 2)
    lru.get(1)
    lru.put(3, 3)
    setResult(JSON.stringify(Array.from(lru.cache.entries())))
  }

  return (
    <div>
      <button onClick={handleClick}>测试 LRUCache</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

总结：

### 字符串相加

<Sandpack>

```js
import { useState } from 'react'

export default function AddStringsDemo() {
  const [result, setResult] = useState('')

  function addStrings(num1, num2) {
    const len = Math.max(num1.length, num2.length)
    num1 = num1.padStart(len, '0')
    num2 = num2.padStart(len, '0')
    // 进位
    let carry = 0
    // 结果
    let result = ''
    for (let i = len - 1; i >= 0; i--) {
      // 当前位相加
      const sum = +num1[i] + +num2[i] + carry
      // 当前位相加结果
      result = (sum % 10) + result
      // 进位
      carry = sum >= 10 ? 1 : 0
    }
    return carry ? '1' + result : result
  }

  function handleClick() {
    setResult(addStrings('123456789123456789', '987654321987654321'))
  }

  return (
    <div>
      <button onClick={handleClick}>测试大数相加</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

总结：
