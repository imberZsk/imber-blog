import { CodeSandbox } from '@/components/CodeSandbox'

[LeetCode 热题 100](https://leetcode.cn/studyplan/top-100-liked/)

### 哈希-001两数之和

```js
var twoSum = function (nums, target) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    const item = nums[i]
    const diff = target - item // 转为差值
    if (map.has(diff)) {
      return [map.get(diff), i]
    }
    map.set(item, i)
  }
}

console.log(twoSum([2, 7, 11, 15], 9))
```

### 哈希-049字母异位分组

排序，map 存数组，然后 map.values() 取答案

```js
var groupAnagrams = function (strs) {
  // map
  const map = new Map()

  // 遍历数组
  for (let str of strs) {
    // 转为数组
    let array = Array.from(str)
    // 排序
    array.sort()
    // 转为字符串
    let key = array.toString()
    // value list
    let list = map.get(key) ? map.get(key) : []
    // 放进。value list 里
    list.push(str)
    // 放进 map
    map.set(key, list)
  }

  // 返回 map 的值
  return Array.from(map.values())
}

groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat'])
```

### 哈希-128最长连续序列

放 nums 进 set，右边没有元素 !numSet.has(num - 1) 开始遍历 set

numSet.has(currentNum + 1) 就一直 set 里找有没有下一个，然后 currentNum++ countLength++

有可能多段 length，再比较取最大的

放进 set 里，然后没有左边的情况开始遍历，中间计数，可能出现多段长度，对比找最大长度

时间复杂度On，空间复杂度On

```js
var longestConsecutive = function (nums) {
  if (nums.length === 0) return 0
  const numSet = new Set(nums)
  let maxLength = 0

  for (const num of numSet) {
    // 没有当前项 - 1 才是起点
    if (!numSet.has(num - 1)) {
      let currentNum = num
      let countLength = 1
      while (numSet.has(currentNum + 1)) {
        currentNum++
        countLength++
      }

      maxLength = Math.max(maxLength, countLength) // cur不再有右邻居，检查count是否最大
    }
  }

  return maxLength
}

console.log(longestConsecutive([0, 1, 2, 3, 5, 6, 7]))
```

### 双指针-283移动零

跟双指针没关系，用的栈，记录size，不是 0 则依次赋值，最后补 0

```js
var moveZeroes = function (nums) {
  // 栈长度
  let size = 0
  // 遍历数组
  for (let num of nums) {
    // 如果不是0
    if (num !== 0) {
      // 重新赋值
      nums[size] = num
      size = size + 1
    }
  }
  // 补 0
  return nums.fill(0, size)
}

console.log(moveZeroes([0, 1, 0, 3, 12]))
```

### 双指针-011盛最多水的容器

左右两边双指针，每次比较左右两边的高度，取小的那个，然后计算面积，然后移动小的那个指针，直到两个指针相遇

```js
var maxArea = function (height) {
  let left = 0
  let right = height.length - 1
  let containerLength = height.length - 1
  let max = 0
  while (left < right) {
    max = Math.max(max, containerLength * Math.min(height[left], height[right]))
    if (height[left] < height[right]) {
      left++
    } else {
      right--
    }
    containerLength--
  }
  return max
}

console.log(maxArea([8, 7, 2, 1]))
```

### 双指针-015三数之和

排序，然后遍历，每次遍历一个数，然后左右指针找另外两个数，如果三个数之和为 0，则加入结果，如果大于 0，则右指针左移，如果小于 0，则左指针右移

```js
var threeSum = function (nums) {
  nums.sort((a, b) => a - b) // 排序
  let target = [] // 排序后[-2,0,1,1,2]

  for (let i = 0; i < nums.length - 2; i++) {
    const item = nums[i]
    let left = i + 1
    let right = nums.length - 1

    if (i > 0 && nums[i] === nums[i - 1]) {
      continue
    }

    while (left < right) {
      let sum = item + nums[right] + nums[left]

      if (sum === 0) {
        target.push([item, nums[left], nums[right]])

        while (nums[left] === nums[left + 1]) {
          left++
        }

        while (nums[right] === nums[right - 1]) {
          right--
        }

        left++
        right--
      }

      if (sum > 0) {
        right--
      }

      if (sum < 0) {
        left++
      }
    }
  }

  return target
}

console.log(threeSum([-1, 0, 1, 2, -1, -4]))
```

### 双指针-042接雨水

左右两边双指针，每次比较左右两边的高度，取大的那个，然后计算面积，然后移动小的那个指针，直到两个指针相遇

```js
var trap = function (height) {
  let ans = 0
  let left = 0,
    right = height.length - 1 // 双指针：左右两端
  let leftMax = 0,
    rightMax = 0 // 记录左右两边的最高值

  while (left < right) {
    // 更新左右两边见过的最高值
    leftMax = Math.max(leftMax, height[left])
    rightMax = Math.max(rightMax, height[right])

    if (height[left] < height[right]) {
      // 左边更低，处理左边的积水
      ans += leftMax - height[left] // 积水 = 左边最高 - 当前高度
      left++
    } else {
      // 右边更低，处理右边的积水
      ans += rightMax - height[right] // 积水 = 右边最高 - 当前高度
      right--
    }
  }
  return ans
}

console.log(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))
```

### 滑动窗口-003无重复字符的最长子串

滑动窗口，维护一个窗口，窗口内没有重复字符，如果有重复字符，则缩小窗口，直到没有重复字符，关键是 ans 这个值一直保留最大值

```js
var lengthOfLongestSubstring = function (s) {
  let ans = 0
  let left = 0
  const window = new Set() // 维护从下标 left 到下标 right 的字符
  for (let right = 0; right < s.length; right++) {
    const c = s[right]
    // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
    // 所以要在加入 c 之前，先移出窗口内的 c
    while (window.has(c)) {
      // 窗口内有 c
      window.delete(s[left])
      left++ // 缩小窗口
    }
    window.add(c) // 加入 c
    ans = Math.max(ans, right - left + 1) // 更新窗口长度最大值
  }
  return ans
}

console.log(lengthOfLongestSubstring('abcabcbb'))
```

### 滑动窗口-438找到字符串中所有字母异位词

这个解法超时了，但是容易看懂

双指针，先排序，然后遍历，每次遍历一个字符串，然后比较是否相等，相等则加入结果，不相等则继续遍历

```js
const toOrder = (str) => Array.from(str).sort().join('')

var findAnagrams = function (s, p) {
  if (s.length < p.length) {
    return []
  }

  let left = 0
  const result = new Set()

  let key = toOrder(p)

  let pLen = p.length

  let sLen = s.length + 1

  for (let right = pLen; right < sLen; right++) {
    let str = s.slice(left, right)
    let sub = toOrder(str)
    if (sub === key) {
      result.add(left)
    }
    left++
  }

  return Array.from(result.values())
}
```

### 子串-560和为K的子数组

暴力解法，两层循环，第一层循环是子数组的起始位置，第二层循环是子数组的结束位置(因为要求子数组是连续的)，然后计算子数组的和，如果和为 k，则计数加一

还有一种解法是用 Set，转差值，然后判断差值是否在 Set 中，在则计数加一，不在则加入 Set

```js
var subarraySum = function (nums, k) {
  let count = 0
  for (let i = 0; i < nums.length; i++) {
    let sum = 0
    for (let j = i; j < nums.length; j++) {
      sum += nums[j]
      if (sum === k) count++
    }
  }
  return count
}
```

### 子串-239滑动窗口最大值

这是一个超时的解法

双指针，左指针是窗口的起始位置，右指针是窗口的结束位置，每次计算窗口内的最大值，然后左指针右移，右指针右移

```js
// 缓存数组的长度
const len = nums.length
// 定义结果数组
const res = []
// 初始化左指针
let left = 0
// 初始化右指针
let right = k - 1
// 当数组没有被遍历完时，执行循环体内的逻辑
while (right < len) {
  // 计算当前窗口内的最大值
  const max = Math.max(...nums.slice(left, right + 1))
  // 将最大值推入结果数组
  res.push(max)
  // 左指针前进一步
  left++
  // 右指针前进一步
  right++
}
// 返回结果数组
return res
```

### 字串-076最小覆盖子串

困难题，略过了～

### 普通数组-053最大子数组和

动态规划暂时还不太理解，先略过

```js
var maxSubArray = function (nums) {
  // 表示以当前元素结尾的最大子数组和
  let pre = 0
  // 记录到目前为止遇到的全局最大值
  let maxAns = nums[0]

  nums.forEach((item) => {
    // 如果 pre + item 大于 item，则说明 pre + item 是当前元素结尾的最大子数组和
    pre = Math.max(pre + item, item)
    // 更新全局最大值
    maxAns = Math.max(maxAns, pre)
  })
  return maxAns
}

console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))
```

### 普通数组-056合并区间

排序，然后遍历，如果当前元素的左边界小于等于上一个元素的右边界，则合并，否则直接加入结果

```js
var merge = function (intervals) {
  let res = []
  intervals.sort((a, b) => a[0] - b[0])

  let prev = intervals[0]

  for (let i = 1; i < intervals.length; i++) {
    let cur = intervals[i]
    if (prev[1] >= cur[0]) {
      // 有重合
      prev[1] = Math.max(cur[1], prev[1])
    } else {
      // 不重合，prev推入res数组
      res.push(prev)
      prev = cur // 更新 prev
    }
  }

  res.push(prev)
  return res
}

console.log(
  merge([
    [1, 3],
    [2, 6],
    [8, 10],
    [15, 18]
  ])
)
```

### 普通数组-189轮转数组

暴力解，超时了，前面加一个后面删一个

```js
var rotate = function (nums, k) {
  const len = nums.length

  let temp = nums[len - 1]
  let count = 0
  for (let i = 0; i < k; i++) {
    temp = nums[len - i - 1 + count]
    nums.unshift(temp)
    nums.pop()
    count++
  }
  return nums
}

console.log(rotate([1, 2, 3, 4, 5], 3))
```

取余，然后直接赋值

```js
var rotate = function (nums, k) {
  const n = nums.length
  const newArr = new Array(n)
  for (let i = 0; i < n; ++i) {
    newArr[(i + k) % n] = nums[i] // 重点
  }
  for (let i = 0; i < n; ++i) {
    nums[i] = newArr[i]
  }
}

console.log(rotate([1, 2, 3, 4, 5], 3))
```

### 普通数组-238除自身以外数组的乘积

左右乘积列表，L 和 R 分别表示左右两侧的乘积列表，然后遍历，L[i] 为索引 i 左侧所有元素的乘积，R[i] 为索引 i 右侧所有元素的乘积，然后遍历，answer[i] = L[i] \* R[i]

```js
var productExceptSelf = function (nums) {
  const length = nums.length

  // L 和 R 分别表示左右两侧的乘积列表
  const L = new Array(length)
  const R = new Array(length)

  const answer = new Array(length)

  // L[i] 为索引 i 左侧所有元素的乘积
  // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1
  L[0] = 1
  for (let i = 1; i < length; i++) {
    L[i] = nums[i - 1] * L[i - 1] // 重点 L[i] 和 L[i - 1]可以表示为前面的累乘
  }

  // R[i] 为索引 i 右侧所有元素的乘积
  // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1
  R[length - 1] = 1
  for (let i = length - 2; i >= 0; i--) {
    R[i] = nums[i + 1] * R[i + 1]
  }

  // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
  for (let i = 0; i < length; i++) {
    answer[i] = L[i] * R[i]
  }

  return answer
}

console.log(productExceptSelf([1, 2, 3, 4]))
```

### 普通数组-041缺失的第一个正数

暴力解法，超时了

```js
var firstMissingPositive = function (nums) {
  const len = nums.length
  let result = 1
  while (true) {
    if (nums.includes(result)) {
      result++
    } else {
      return result
    }
  }
}

console.log(firstMissingPositive([1, 2, 0]))
```

### 链表-160相交链表

用 set 存一个链表，然后遍历另一个链表，如果 set 中包含当前节点，则返回当前节点

```js
var getIntersectionNode = function (headA, headB) {
  const set = new Set()
  let temp = headA
  while (temp !== null) {
    set.add(temp)
    temp = temp.next
  }

  temp = headB
  while (temp !== null) {
    if (set.has(temp)) {
      return temp
    }
    temp = temp.next
  }
  return null
}
```

### 链表-206反转链表

pre 是前一个节点，cur 是当前节点，next 是下一个节点，每次将当前节点指向前一个节点，然后前一个节点向后移动，当前节点向后移动

```js
var reverseList = function (head) {
  let pre = null
  let cur = head
  while (cur !== null) {
    let next = cur.next
    // 当前节点指向前一个节点
    cur.next = pre // 重点，每次下一个指向前一个
    // 前一个节点向后移动
    pre = cur
    // 当前节点向后移动
    cur = next
  }
  return pre
}

console.log(
  reverseList({
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: null
      }
    }
  })
)
```

### 链表-234回文链表

用数组存链表，然后遍历数组，双指针从两边到中间，如果数组中元素不等于数组中元素的倒序，则返回 false

```js
var isPalindrome = function (head) {
  let arr = []
  let left = head

  let right

  while (head) {
    arr.push(head.val)
    head = head.next
  }

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] !== arr[arr.length - 1 - i]) {
      return false
    }
  }

  return true
}

console.log(
  isPalindrome({
    value: 1,
    next: {
      value: 2
      next: {
        value: 1,
        next: null
      }
    }
  })
)
```

### 链表-141环形链表

每个遍历到的元素都给flag，如果遍历到了flag则有环

或者快慢指针，因为有环的话一定会重合

```js
var hasCycle = function (head) {
  while (head) {
    if (head.flag) {
      return true
    } else {
      head.flag = true
      head = head.next
    }
  }

  return false
}

var hasCycle = function (head) {
  let slow = head
  let fast = head // 乌龟和兔子同时从起点出发
  while (fast && fast.next) {
    // 如果有环的话会一直走环，一定会追上
    slow = slow.next // 乌龟走一步
    fast = fast.next.next // 兔子走两步
    if (fast === slow) {
      // 兔子追上乌龟（套圈），说明有环
      return true
    }
  }
  return false // 访问到了链表末尾，无环
}
```

### 链表-142环形链表2

返回第一个节点

```js
var detectCycle = function (head) {
  while (head) {
    if (head.flag) {
      return head
    } else {
      head.flag = true
      head = head.next
    }
  }
  return null
}
```

### 链表-021合并两个有序链表

```js
//穿针引线
var mergeTwoLists = function (list1, list2) {
  let head = new ListNode()
  let cur = head
  while (list1 && list2) {
    // 如果list1的值更小，穿list1，并且list1++
    if (list1.val <= list2.val) {
      cur.next = list1
      list1 = list1.next
    } else {
      cur.next = list2
      list2 = list2.next
    }
    // 针也要移动一位
    cur = cur.next
  }

  // 链表不等长的时候，因为是有序的，可以直接拼接
  cur.next = list1 !== null ? list1 : list2

  return head.next
}
```
