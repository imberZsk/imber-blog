import { CodeSandbox } from '@/components/CodeSandbox'

## 数组相关

### 两数之和

<Sandpack>

```js
import { useState } from 'react'

export default function TwoSumDemo() {
  const [result, setResult] = useState('')

  function twoSum(nums, target) {
    const diffs = {}
    const len = nums.length
    for (let i = 0; i < len; i++) {
      if (diffs[target - nums[i]] !== undefined) {
        return [diffs[target - nums[i]], i]
      }
      diffs[nums[i]] = i
    }
  }

  function handleClick() {
    setResult(JSON.stringify(twoSum([2, 7, 11, 15], 9)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试两数之和</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

### 合并两个有序数组

<Sandpack>

```js
import { useState } from 'react'

export default function MergeArrayDemo() {
  const [result, setResult] = useState('')

  function merge(nums1, m, nums2, n) {
    let i = m - 1,
      j = n - 1,
      k = m + n - 1
    while (i >= 0 && j >= 0) {
      if (nums1[i] >= nums2[j]) {
        nums1[k] = nums1[i]
        i--
        k--
      } else {
        nums1[k] = nums2[j]
        j--
        k--
      }
    }
    while (j >= 0) {
      nums1[k] = nums2[j]
      k--
      j--
    }
    return nums1
  }

  function handleClick() {
    setResult(JSON.stringify(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3)))
  }

  return (
    <div>
      <button onClick={handleClick}>测试合并有序数组</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

### 三数之和

<Sandpack>

```js
import { useState } from 'react'

export default function ThreeSumDemo() {
  const [result, setResult] = useState('')

  function threeSum(nums) {
    let res = []
    nums = nums.sort((a, b) => a - b)
    const len = nums.length
    for (let i = 0; i < len - 2; i++) {
      let j = i + 1
      let k = len - 1
      if (i > 0 && nums[i] === nums[i - 1]) continue
      while (j < k) {
        if (nums[i] + nums[j] + nums[k] < 0) {
          j++
          while (j < k && nums[j] === nums[j - 1]) j++
        } else if (nums[i] + nums[j] + nums[k] > 0) {
          k--
          while (j < k && nums[k] === nums[k + 1]) k--
        } else {
          res.push([nums[i], nums[j], nums[k]])
          j++
          k--
          while (j < k && nums[j] === nums[j - 1]) j++
          while (j < k && nums[k] === nums[k + 1]) k--
        }
      }
    }
    return res
  }

  function handleClick() {
    setResult(JSON.stringify(threeSum([-1, 0, 1, 2, -1, -4])))
  }

  return (
    <div>
      <button onClick={handleClick}>测试三数之和</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

## 长度最小的子数组

```js

```

## 字符串操作

### 验证回文字符串

<Sandpack>

```js
import { useState } from 'react'

export default function PalindromeDemo() {
  const [result, setResult] = useState('')

  function isPalindrome(str) {
    const len = str.length
    for (let i = 0; i < len / 2; i++) {
      if (str[i] !== str[len - i - 1]) {
        return false
      }
    }
    return true
  }

  function handleClick() {
    setResult(isPalindrome('abccba') ? '是回文' : '不是回文')
  }

  return (
    <div>
      <button onClick={handleClick}>测试回文字符串</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

### 最多删除一个字符。判断是否能成为回文字符串

<Sandpack>

```js
import { useState } from 'react'

export default function ValidPalindromeDemo() {
  const [result, setResult] = useState('')

  function validPalindrome(s) {
    const len = s.length
    let i = 0,
      j = len - 1
    while (i < j && s[i] === s[j]) {
      i++
      j--
    }
    if (isPalindrome(i + 1, j)) return true
    if (isPalindrome(i, j - 1)) return true
    function isPalindrome(st, ed) {
      while (st < ed) {
        if (s[st] !== s[ed]) return false
        st++
        ed--
      }
      return true
    }
    return false
  }

  function handleClick() {
    setResult(validPalindrome('abca') ? '可以' : '不可以')
  }

  return (
    <div>
      <button onClick={handleClick}>测试最多删除一个字符回文</button>
      <div>结果：{result}</div>
    </div>
  )
}
```

</Sandpack>

## 链表问题

### 合并两个有序链表

<CodeSandbox
  code={`function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0)
  // 穿针引线，也有点像双指针
  let curr = dummy
  while (l1 && l2) {
    if (l1.val < l2.val) {
      curr.next = l1
      l1 = l1.next
    } else {
      curr.next = l2
      l2 = l2.next
    }
    curr = curr.next
  }
  curr.next = l1 || l2
  return dummy.next
}`}
/>

### 删除链表倒数第 N 个节点

快慢指针

<CodeSandbox code={`function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0)
  dummy.next = head
  let fast = dummy
  let slow = dummy

// 只走n步
for (let i = 0; i <= n; i++) {
fast = fast.next
}

// 一起走
while (fast) {
fast = fast.next
slow = slow.next
}
slow.next = slow.next.next
return dummy.next
}`} />

### 反转链表

记录下一个节点

<CodeSandbox
  code={`function reverseList(head) {
  let prev = null
  let curr = head
  while (curr) {
    const next = curr.next
    curr.next = prev
    prev = curr
    curr = next
  }
  return prev
}`}
/>

### 环形链表检测

快慢指针，或者打一个flag标识

<CodeSandbox
  code={`function hasCycle(head) {
  let slow = head
  let fast = head
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
    if (slow === fast) return true
  }
  return false
}`}
/>

## 栈

### 有效的括号

<CodeSandbox code={`function isValid(s) {
  const stack = []
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  }
  for (let char of s) {
    if (map[char]) {
      stack.push(char)
    } else {
      if (stack.length === 0 || map[stack.pop()] !== char) {
        return false
      }
    }
  }
  return stack.length === 0
}

// 用一个 map 来维护左括号和右括号的对应关系
const leftToRight = {
'(': ')',
'[': ']',
'{': '}'
}

/\*\*

- @param {string} s
- @return {boolean}
  \*/
  const isValid = function (s) {
  // 结合题意，空字符串无条件判断为 true
  if (!s) {
  return true
  }
  // 初始化 stack 数组
  const stack = []
  // 缓存字符串长度
  const len = s.length
  // 遍历字符串
  for (let i = 0; i < len; i++) {
  // 缓存单个字符
  const ch = s[i]
  // 判断是否是左括号，这里我为了实现加速，没有用数组的 includes 方法，直接手写判断逻辑
  if (ch === '(' || ch === '{' || ch === '[') stack.push(leftToRight[ch])
  // 若不是左括号，则必须是和栈顶的左括号相配对的右括号
  else {
  // 若栈为空，或栈顶的左括号没有和当前字符匹配上，那么判为无效
  if (!stack.length || stack.pop() !== ch) {
  return false
  }
  }
  }
  // 若所有的括号都能配对成功，那么最后栈应该是空的
  return !stack.length
  }`} />

## 队列

### 滑动窗口

```js

```

## 树相关

### 二叉树的前序遍历

<CodeSandbox code={`function preorderTraversal(root) {
  const result = []
  function traverse(node) {
    if (!node) return
    result.push(node.val)
    traverse(node.left)
    traverse(node.right)
  }
  traverse(root)
  return result
}

// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
// 递归边界，root 为空
if (!root) {
return
}

// 输出当前遍历的结点值
console.log('当前遍历的结点值是：', root.val)
// 递归遍历左子树
preorder(root.left)
// 递归遍历右子树
preorder(root.right)
}`} />

### 二叉树的层序遍历

<CodeSandbox code={`function levelOrder(root) {
  if (!root) return []
  const result = []
  const queue = [root]
  while (queue.length) {
    const level = []
    const size = queue.length
    for (let i = 0; i < size; i++) {
      const node = queue.shift()
      level.push(node.val)
      if (node.left) queue.push(node.left)
      if (node.right) queue.push(node.right)
    }
    result.push(level)
  }
  return result
}

function BFS(root) {
const queue = [] // 初始化队列queue
// 根结点首先入队
queue.push(root)
// 队列不为空，说明没有遍历完全
while (queue.length) {
const top = queue[0] // 取出队头元素
// 访问 top
console.log(top.val)
// 如果左子树存在，左子树入队
if (top.left) {
queue.push(top.left)
}
// 如果右子树存在，右子树入队
if (top.right) {
queue.push(top.right)
}
queue.shift() // 访问完毕，队头元素出队
}
}`} />

## 排序和搜索

### 快速排序

<CodeSandbox
  code={`function quickSort(arr) {
  if (arr.length <= 1) return arr
  const pivot = arr[0]
  const left = []
  const right = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)]
}`}
/>

### 二分查找

<CodeSandbox
  code={`function binarySearch(nums, target) {
  let left = 0
  let right = nums.length - 1
  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    if (nums[mid] === target) return mid
    if (nums[mid] < target) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}`}
/>

## 动态规划

### 爬楼梯问题

<CodeSandbox
  code={`function climbStairs(n) {
  if (n <= 2) return n
  let dp = [1, 2]
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n - 1]
}`}
/>

### 买卖股票的最佳时机

<CodeSandbox
  code={`function maxProfit(prices) {
  let minPrice = Infinity
  let maxProfit = 0
  for (let price of prices) {
    minPrice = Math.min(minPrice, price)
    maxProfit = Math.max(maxProfit, price - minPrice)
  }
  return maxProfit
}`}
/>

### 打家劫舍问题

<CodeSandbox
  code={`function rob(nums) {
  if (nums.length === 0) return 0
  if (nums.length === 1) return nums[0]
  const dp = [nums[0], Math.max(nums[0], nums[1])]
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  return dp[nums.length - 1]
}`}
/>
