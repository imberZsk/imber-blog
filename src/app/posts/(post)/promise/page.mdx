import { CodeSandbox } from '@/components/CodeSandbox'

## Promise 打印执行顺序

### 题目 1：async/await

<CodeSandbox code={`async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}

async function async2() {
console.log('async2')
}

console.log('script start')

setTimeout(() => console.log('setTimeout'), 0)

async1()

new Promise((resolve) => {
console.log('promise1')
resolve()
}).then(() => {
console.log('promise2')
})

console.log('script end')

// 输出
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout`} />

解释：await fn，这个fn仍然是同步，但是 await fn后面的成了微任务

### 题目 2：resolve

<CodeSandbox code={`console.log('1')

setTimeout(() => console.log('2'), 10)

new Promise((resolve) => {
console.log('3')
resolve()
console.log('4')
}).then(() => console.log('5'))

setTimeout(() => console.log('6'), 0)

console.log('7')

// 输出 1 3 4 7 5 6 2`} />

解释：resolve 不会阻止当前的同步执行，所以先打印3，4，执行完了同步再执行resolve

### 题目 3：then

<CodeSandbox code={`async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 middle')
  await async3()
  console.log('async1 end')
}

async function async2() {
console.log('async2')
}

async function async3() {
console.log('async3')
}

console.log('script start')

setTimeout(() => console.log('setTimeout'), 0)

async1()

new Promise((resolve) => {
console.log('promise1')
resolve(1)
})
.then((res) => {
console.log('promise2', res)
return Promise.resolve(2)
})
.then((res) => {
console.log('promise3', res)
})

console.log('script end')

// 输出
// script start
// async1 start
// async2
// promise1
// script end
// async1 middle
// async3
// promise2
// async1 end
// promise3
// setTimeout`} />

解释：多个 then 都会执行

### 题目 4：Promise.all

<CodeSandbox code={`console.log('start')

Promise.all([
new Promise((resolve) => {
setTimeout(() => {
console.log('promise1')
resolve(1)
}, 2000)
}),
new Promise((resolve) => {
setTimeout(() => {
console.log('promise2')
resolve(2)
}, 1000)
})
]).then((res) => {
console.log('all done', res)
})

console.log('end')

// 输出
// start
// end
// promise2
// promise1
// all done [1, 2]`} />

解释：promise.all 会等待所有 promise 都执行完，然后执行 then

### 题目 5：事件循环

<CodeSandbox code={`console.log('1')

setTimeout(() => {
console.log('2')
Promise.resolve().then(() => console.log('3'))
}, 0)

new Promise((resolve) => {
console.log('4')
resolve()
}).then(() => {
console.log('5')
setTimeout(() => console.log('6'), 0)
})

Promise.resolve().then(() => console.log('7'))

console.log('8')

// 输出 1 4 8 5 7 2 3 6`} />

解释：清空完微任务再执行宏任务
