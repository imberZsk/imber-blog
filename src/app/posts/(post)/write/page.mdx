## 手写题

### 控制请求并发

```javascript
function controlConcurrent(arr, max) {
  let running = 0 // 当前正在执行的请求数
  let index = 0 // 当前要执行的请求索引

  function runNext() {
    // 如果所有请求都已执行完，或者当前正在执行的请求数达到最大值，则返回
    if (index >= arr.length || running >= max) {
      return
    }

    running++ // 增加正在执行的请求数
    const currentIndex = index++

    // 执行当前请求
    arr[currentIndex]()
      .then(() => {
        console.log(`请求 ${currentIndex + 1} 完成`)
      })
      .catch((err) => {
        console.error(`请求 ${currentIndex + 1} 失败:`, err)
      })
      .finally(() => {
        running-- // 减少正在执行的请求数
        runNext() // 执行下一个请求
      })
  }

  // 启动初始的 max 个请求
  for (let i = 0; i < max; i++) {
    runNext()
  }
}
```

## 数组相关

### 旋转数组

```javascript
function rotate(nums, k) {
  k = k % nums.length
  nums.unshift(...nums.splice(-k))
  return nums
}
```

### 最大子序和

```javascript
function maxSubArray(nums) {
  let max = nums[0]
  let sum = 0
  for (let num of nums) {
    sum = Math.max(sum + num, num)
    max = Math.max(max, sum)
  }
  return max
}
```

## 字符串操作

### 反转字符串

```javascript
function reverseString(str) {
  return str.split('').reverse().join('')
}
```

### 验证回文字符串

```javascript
function isPalindrome(str) {
  str = str.toLowerCase().replace(/[^a-z0-9]/g, '')
  return str === str.split('').reverse().join('')
}
```

### 最长公共前缀

```javascript
function longestCommonPrefix(strs) {
  if (strs.length === 0) return ''
  let prefix = strs[0]
  for (let i = 1; i < strs.length; i++) {
    while (strs[i].indexOf(prefix) !== 0) {
      prefix = prefix.substring(0, prefix.length - 1)
      if (prefix === '') return ''
    }
  }
  return prefix
}
```

### 字符串转换整数

```javascript
function myAtoi(str) {
  const num = parseInt(str.trim())
  if (isNaN(num)) return 0
  const INT_MAX = 2 ** 31 - 1
  const INT_MIN = -(2 ** 31)
  return Math.max(Math.min(num, INT_MAX), INT_MIN)
}
```

### 有效的括号

```javascript
function isValid(s) {
  const stack = []
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  }
  for (let char of s) {
    if (map[char]) {
      stack.push(char)
    } else {
      if (stack.length === 0 || map[stack.pop()] !== char) {
        return false
      }
    }
  }
  return stack.length === 0
}
```

## 链表问题

### 反转链表

```javascript
function reverseList(head) {
  let prev = null
  let curr = head
  while (curr) {
    const next = curr.next
    curr.next = prev
    prev = curr
    curr = next
  }
  return prev
}
```

### 环形链表检测

```javascript
function hasCycle(head) {
  let slow = head
  let fast = head
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
    if (slow === fast) return true
  }
  return false
}
```

### 合并两个有序链表

```javascript
function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0)
  let curr = dummy
  while (l1 && l2) {
    if (l1.val < l2.val) {
      curr.next = l1
      l1 = l1.next
    } else {
      curr.next = l2
      l2 = l2.next
    }
    curr = curr.next
  }
  curr.next = l1 || l2
  return dummy.next
}
```

### 删除链表倒数第 N 个节点

```javascript
function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0)
  dummy.next = head
  let fast = dummy
  let slow = dummy
  for (let i = 0; i <= n; i++) {
    fast = fast.next
  }
  while (fast) {
    fast = fast.next
    slow = slow.next
  }
  slow.next = slow.next.next
  return dummy.next
}
```

### 相交链表

```javascript
function getIntersectionNode(headA, headB) {
  let a = headA
  let b = headB
  while (a !== b) {
    a = a ? a.next : headB
    b = b ? b.next : headA
  }
  return a
}
```

## 树相关

### 二叉树的前序遍历

```javascript
function preorderTraversal(root) {
  const result = []
  function traverse(node) {
    if (!node) return
    result.push(node.val)
    traverse(node.left)
    traverse(node.right)
  }
  traverse(root)
  return result
}
```

### 二叉树的最大深度

```javascript
function maxDepth(root) {
  if (!root) return 0
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
}
```

### 对称二叉树判断

```javascript
function isSymmetric(root) {
  function isMirror(left, right) {
    if (!left && !right) return true
    if (!left || !right) return false
    return left.val === right.val && isMirror(left.left, right.right) && isMirror(left.right, right.left)
  }
  return isMirror(root, root)
}
```

### 二叉树的层序遍历

```javascript
function levelOrder(root) {
  if (!root) return []
  const result = []
  const queue = [root]
  while (queue.length) {
    const level = []
    const size = queue.length
    for (let i = 0; i < size; i++) {
      const node = queue.shift()
      level.push(node.val)
      if (node.left) queue.push(node.left)
      if (node.right) queue.push(node.right)
    }
    result.push(level)
  }
  return result
}
```

### 验证二叉搜索树

```javascript
function isValidBST(root) {
  function validate(node, min, max) {
    if (!node) return true
    if (node.val <= min || node.val >= max) return false
    return validate(node.left, min, node.val) && validate(node.right, node.val, max)
  }
  return validate(root, -Infinity, Infinity)
}
```

## 排序和搜索

### 快速排序

```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr
  const pivot = arr[0]
  const left = []
  const right = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)]
}
```

### 二分查找

```javascript
function binarySearch(nums, target) {
  let left = 0
  let right = nums.length - 1
  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    if (nums[mid] === target) return mid
    if (nums[mid] < target) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}
```

### 合并两个有序数组

```javascript
function merge(nums1, m, nums2, n) {
  let i = m - 1
  let j = n - 1
  let k = m + n - 1
  while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) {
      nums1[k--] = nums1[i--]
    } else {
      nums1[k--] = nums2[j--]
    }
  }
  while (j >= 0) {
    nums1[k--] = nums2[j--]
  }
}
```

### 第一个错误的版本

```javascript
function firstBadVersion(n) {
  let left = 1
  let right = n
  while (left < right) {
    const mid = Math.floor((left + right) / 2)
    if (isBadVersion(mid)) {
      right = mid
    } else {
      left = mid + 1
    }
  }
  return left
}
```

### 搜索旋转排序数组

```javascript
function search(nums, target) {
  let left = 0
  let right = nums.length - 1
  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    if (nums[mid] === target) return mid
    if (nums[left] <= nums[mid]) {
      if (target >= nums[left] && target < nums[mid]) {
        right = mid - 1
      } else {
        left = mid + 1
      }
    } else {
      if (target > nums[mid] && target <= nums[right]) {
        left = mid + 1
      } else {
        right = mid - 1
      }
    }
  }
  return -1
}
```

## 动态规划

### 爬楼梯问题

```javascript
function climbStairs(n) {
  if (n <= 2) return n
  let dp = [1, 2]
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n - 1]
}
```

### 买卖股票的最佳时机

```javascript
function maxProfit(prices) {
  let minPrice = Infinity
  let maxProfit = 0
  for (let price of prices) {
    minPrice = Math.min(minPrice, price)
    maxProfit = Math.max(maxProfit, price - minPrice)
  }
  return maxProfit
}
```

### 打家劫舍问题

```javascript
function rob(nums) {
  if (nums.length === 0) return 0
  if (nums.length === 1) return nums[0]
  const dp = [nums[0], Math.max(nums[0], nums[1])]
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  return dp[nums.length - 1]
}
```

### 零钱兑换

```javascript
function coinChange(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity)
  dp[0] = 0
  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1)
      }
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
}
```

## 其他常见问题

### LRU 缓存

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity
    this.cache = new Map()
  }

  get(key) {
    if (!this.cache.has(key)) return -1
    const value = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key, value)
    return value
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    } else if (this.cache.size >= this.capacity) {
      this.cache.delete(this.cache.keys().next().value)
    }
    this.cache.set(key, value)
  }
}
```

### Promise.all 实现

```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const results = []
    let count = 0
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((result) => {
          results[index] = result
          count++
          if (count === promises.length) {
            resolve(results)
          }
        })
        .catch(reject)
    })
  })
}
```

### 函数柯里化

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return function (...args2) {
      return curried.apply(this, args.concat(args2))
    }
  }
}
```

### 防抖和节流实现

```javascript
// 防抖
function debounce(fn, delay) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 节流
function throttle(fn, delay) {
  let lastTime = 0
  return function (...args) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}
```
