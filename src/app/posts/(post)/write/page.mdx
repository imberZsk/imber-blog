### 控制请求并发

```javascript
function controlConcurrent(arr, max) {
  let running = 0 // 当前正在执行的请求数
  let index = 0 // 当前要执行的请求索引

  function runNext() {
    // 如果所有请求都已执行完，或者当前正在执行的请求数达到最大值，则返回
    if (index >= arr.length || running >= max) {
      return
    }

    running++ // 增加正在执行的请求数
    const currentIndex = index++

    // 执行当前请求
    arr[currentIndex]()
      .then(() => {
        console.log(`请求 ${currentIndex + 1} 完成`)
      })
      .catch((err) => {
        console.error(`请求 ${currentIndex + 1} 失败:`, err)
      })
      .finally(() => {
        running-- // 减少正在执行的请求数
        runNext() // 执行下一个请求
      })
  }

  // 启动初始的 max 个请求
  for (let i = 0; i < max; i++) {
    runNext()
  }
}
```

### new

```js
// function new(fn){
//   // const newObj = {}
//   // newObj.__proto__ = fn.prototype
//   const newObj = Object.create(fn.prototype)
//   const res = fn.apply(newObj,arguments)
//   return typeof(res) === 'object' && res !== null ? res : newObj
// }

function _new(Fn, ...args) {
  const obj = Object.create(Fn.prototype)
  const result = Fn.apply(obj, args)
  return result instanceof Object ? result : obj
}
```

### instanceof

```js
// function instanceof(a,b){
//   const l = a.__proto__
//   const r = b.prototype
//   while(true){
//     if(l===null){
//       return false
//     }
//     if(l === r){
//       return true
//     }
//     l = l.__proto__
//   }
// }

function instanceOf(obj, fn) {
  let proto = Object.getPrototypeOf(obj) // 获取对象的原型
  while (proto !== null) {
    if (proto === fn.prototype) {
      return true
    }
    proto = Object.getPrototypeOf(proto) // 继续向上查找
  }
  return false
}
```

### 深拷贝

```js
// function deepClone(obj, cache = new WeakMap()) {
//   if (typeof obj !== 'object' || obj === null) return
//   if (cache.has(obj)) {
//     return cache.get(obj)
//   }
//   const target = obj instanceof Array ? [] : {}
//   cache.set(obj, target)
//   for (let key in obj) {
//     if (obj.hasOwnProperty(key)) {
//       target[key] = deepClone(obj[key], cache)
//     }
//   }

//   return target
// }

function deepClone(obj, cache = new WeakMap()) {
  // 处理基本类型和null/undefined
  if (obj === null || typeof obj !== 'object') {
    return obj // 这里应该返回原值，而不是undefined
  }

  // 处理循环引用
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  // 处理特殊对象类型
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)

  // 初始化克隆对象
  const target = Array.isArray(obj) ? [] : {}

  // 保存引用，防止循环引用
  cache.set(obj, target)

  // 递归拷贝属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      target[key] = deepClone(obj[key], cache)
    }
  }

  return target
}
```

### 数组转数

```js
function arrayToTree(items, id = null, link = 'parentId') {
  return items
    .filter((item) => item[link] === id)
    .map((item) => ({
      ...item,
      children: arrayToTree(items, item.id)
    }))
}
```

### 拍平数组

```js
// 测试数据
const a = [
  [1, 2],
  [3, 4],
  [2, 3, 4, [7, 4, 9]]
]
// 递归
function flat(arr) {
  const target = []
  arr.forEach((item) => {
    if (item instanceof Array) {
      target.push(...flat(item))
    } else {
      target.push(item)
    }
  })
  return target
}
// reduce
function flat(arr) {
  let res = arr.reduce((pre, next) => {
    return pre.concat(Array.isArray(next) ? flat(next) : next)
  }, [])
  return res
}
```

### 大数相加

```js
// ## 逻辑

// 拿到两个字符串最长 length，然后用 padStart 在前面加 0

// 定义一个 carry 表示进位，然后 for 循环，用 i = len - 1 来做循环，因为要从最后面开始加

// 定义一个 result 表示最后的结果

// 循环里定义一个 sum，表示每次相加（转数字再加），然后判断是否有 carry(是否>10)，有的话 result += sum % 10

// 最后返回看是否有 carry，有的话 result + 1 否则 result

// ## 核心思想

// 前面补 0，末尾相加，每次判断是否有进位

/**
 * @params {String} num1
 * @params {String} num2
 */

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function (num1, num2) {
  const len = Math.max(num1.length, num2.length)
  num1 = num1.padStart(len, '0')
  num2 = num2.padStart(len, '0')
  let carry = 0
  let result = ''
  for (let i = len - 1; i >= 0; i--) {
    const sum = +num1[i] + +num2[i] + carry
    // 取余数
    result = (sum % 10) + result
    carry = sum >= 10 ? 1 : 0
  }
  return carry ? '1' + result : result
}
```

### LRU 缓存

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity
    this.cache = new Map()
  }

  get(key) {
    if (!this.cache.has(key)) return -1
    const value = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key, value)
    return value
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    } else if (this.cache.size >= this.capacity) {
      this.cache.delete(this.cache.keys().next().value)
    }
    this.cache.set(key, value)
  }
}
```

### Promise.all 实现

```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const results = []
    let count = 0
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((result) => {
          results[index] = result
          count++
          if (count === promises.length) {
            resolve(results)
          }
        })
        .catch(reject)
    })
  })
}
```

### 函数柯里化

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return function (...args2) {
      return curried.apply(this, args.concat(args2))
    }
  }
}
```

### 防抖和节流实现

```javascript
// 防抖
function debounce(fn, delay) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 节流
function throttle(fn, delay) {
  let lastTime = 0
  return function (...args) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}
```

### 版本号排序

```js
function compareVersion(version1, version2) {
  const v1 = version1.split('.')
  const v2 = version2.split('.')
  const length = Math.max(v1.length, v2.length)
  for (let i = 0; i < length; i++) {
    const num1 = parseInt(v1[i] || 0)
    const num2 = parseInt(v2[i] || 0)
    if (num1 !== num2) {
      return num1 - num2
    }
  }
  return 0
}
function sortVersions(versions) {
  return versions.sort(compareVersion)
}
console.log(sortVersions(['0.1.2', '0.2.1', '0.0.1', '2.0.0', '1.0.221']))
```
